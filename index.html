<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Gamedev Canvas Workshop | Josh Williams</title>
    <style>
        * { padding: 0; margin: 0; }
        canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>

<script>
    // Store canvas and 2d rendering content that we use to paint the canvas
    var canvas = document.getElementById("myCanvas");
    var ctx = canvas.getContext("2d");
    // Canvas dimensions.
    var x = canvas.width/2;
    var y = canvas.height-30;
    // Ball variables.
    var ballRadius = 10;
    var dx = 2;
    var dy = -2;
    // Paddle variables.
    var paddleHeight = 10;
    var paddleWidth = 75;
    var paddleX = (canvas.width - paddleWidth) / 2;
    var rightPressed = false;
    var leftPressed = false;
    // Brick variables.
    var brickRowCount = 3;
    var brickColumnCount = 5;
    var brickWidth = 75;
    var brickHeight = 20;
    var brickPadding = 10;
    var brickOffsetTop = 30;
    var brickOffsetLeft = 30;
    var bricks = [];

    var score = 0;

    var lives = 3;

    // Fill the 2D bricks array. more of an array object now?
    for(c=0; c<brickColumnCount; c++) {
      bricks[c] = [];
      for(r=0; r<brickRowCount; r++) {
        bricks[c][r] = { x: 0, y: 0, status: 1 };
      }
    }
    // Controls event listeners
    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);
    document.addEventListener("mousemove", mouseMoveHandler, false);

    function keyDownHandler(e) {
      if(e.keyCode == 39) {
        rightPressed = true;
      }
      if(e.keyCode == 37) {
        leftPressed = true;
      }
    }

    function keyUpHandler(e) {
      if(e.keyCode == 39) {
        rightPressed = false;
      }
      if(e.keyCode == 37) {
        leftPressed = false;
      }
    }

    function mouseMoveHandler(e) {
      // RelativeX = mouse x coordinates.
      var relativeX = e.clientX - canvas.offsetLeft;
      if(relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
      }
    }

    function collisionDetection(){
      for(c=0; c<brickColumnCount; c++) {
        for(r=0; r<brickRowCount; r++) {
          var b = bricks[c][r];
          if(b.status == 1) {
            // Check if the ball is inside any of the bricks.
            if(x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
              // Block has been hit! Flip ball direction update block status and up score.
              dy = -dy;
              b.status = 0;
              score++;
              if(score == brickRowCount * brickColumnCount) {
                alert("YOU WIN, CONGRATULATIONS!");
                document.location.reload();
              }
            }
          }
        }
      }
    }

    function drawScore() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#0095DD";
      // (text to display, x coordinates, y coordinates)
      ctx.fillText("Score: " + score, 8, 20);
    }

    function drawLives() {
      ctx.font = "16px Arial";
      ctx.fillStyle = "#0095DD";
      // (text to display, x coordinates, y coordinates)
      ctx.fillText("Lives: " + lives, canvas.width - 65, 20);
    }

    function drawBricks() {
      for(c=0; c<brickColumnCount; c++) {
        for(r=0; r<brickRowCount; r++) {
          // Don't draw destroyed bricks.
          if(bricks[c][r].status == 1) {
            var brickX = (c*(brickWidth + brickPadding)) + brickOffsetLeft;
            var brickY = (r*(brickHeight + brickPadding)) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(x, y, ballRadius, 0, Math.PI*2);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();
    }

    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
      ctx.fillStyle = "#0095DD";
      ctx.fill();
      ctx.closePath();
    }

    function draw() {
      // Clear the canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      drawScore();
      drawLives();
      collisionDetection();

      // Check left & right boundaries.
      if(x + dx < ballRadius || x + dx > canvas.width - ballRadius) {
        dx = -dx;
      }
      // Check top boundary and reload if bottom boundary is hit.
      if(y + dy < ballRadius) {
        dy = -dy;
      }
      else if(y + dy > canvas.height - ballRadius) {
        if(x > paddleX && x < paddleX + paddleWidth) {
          dy = -dy;
        }
        else {
          lives--;
          if(!lives) {
            alert("GAME OVER");
            document.location.reload();
          }
          else {
            x = canvas.width / 2;
            y = canvas.height - 30;
            dx = 2;
            dy = -2;
            paddleX = (canvas.width - paddleWidth) / 2;
          }
        }
      }

      if(rightPressed && paddleX < canvas.width - paddleWidth) {
        paddleX += 7;
      }
      else if (leftPressed && paddleX > 0) {
        paddleX -= 7;
      }
      // Add speed to ball for its next position update.
      x += dx;
      y += dy;

      /* The draw() function is now getting executed again and again within a
      requestAnimationFrame() loop, but instead of the fixed 10 milliseconds
      frame rate, we are giving control of the framerate back to the browser.
      It will sync the framerate accordingly and render the shapes only when
      needed. This produces a more efficient, smoother animation loop than the
      older setInterval() method.
      */
      requestAnimationFrame(draw);
    }

    draw();
</script>

</body>
</html>
